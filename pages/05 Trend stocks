# pages/Trend stocks.py
import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime
import os

# =========================================================================
# CONFIGURACIÃ“N
# =========================================================================

st.set_page_config(page_title="Trend stocks", layout="wide")

# =========================================================================
# 1. CARGA Y PROCESAMIENTO DE DATOS
# =========================================================================

@st.cache_data(ttl=3600, show_spinner=False)
def cargar_datos_csv():
    """Carga el CSV principal con datos de acciones"""
    st.subheader("1. Carga de Datos")
    
    csv_files = ['explorer.csv.csv', '1762686384523_explorer.csv.csv', 'explorer.csv']
    df = None
    
    for csv_file in csv_files:
        if os.path.exists(csv_file):
            try:
                df = pd.read_csv(csv_file)
                st.success(f"âœ… Archivo '{csv_file}' cargado correctamente: {len(df)} registros")
                break
            except Exception as e:
                st.error(f"âŒ Error al leer '{csv_file}': {e}")
    
    if df is None:
        st.error("âŒ No se encontrÃ³ ningÃºn archivo CSV vÃ¡lido")
        st.info("ğŸ“ AsegÃºrate de tener 'explorer.csv.csv' o 'explorer.csv' en el directorio raÃ­z")
        return None
    
    return df

@st.cache_data(ttl=3600, show_spinner=False)
def simular_datos_opciones(df):
    """
    Simula datos de opciones (call/put ratio y volumen).
    NOTA: Reemplazar con datos reales de tu API cuando estÃ© disponible.
    """
    if df is None:
        return None
    
    df_opciones = df.copy()
    
    # Simular datos de opciones basados en caracterÃ­sticas reales
    np.random.seed(42)
    
    # Volumen de opciones correlacionado con volumen de acciones
    df_opciones['Options_Volume'] = (df_opciones['Volumen'] * 
                                      np.random.uniform(0.05, 0.3, len(df_opciones))).astype(int)
    
    # Call/Put Ratio con distribuciÃ³n realista
    # Mayor ratio en acciones con tendencia alcista (ROC positivo)
    base_ratio = np.random.lognormal(0, 0.5, len(df_opciones))
    
    # Ajustar ratio segÃºn momentum (ROC18)
    momentum_factor = 1 + (df_opciones['ROC18'] / 100) * 0.3
    df_opciones['Call_Put_Ratio'] = (base_ratio * momentum_factor).clip(0.1, 5.0)
    
    return df_opciones

# =========================================================================
# 2. FILTROS Y PARÃMETROS
# =========================================================================

def seccion_filtros():
    """SecciÃ³n de configuraciÃ³n de filtros"""
    st.subheader("2. ConfiguraciÃ³n de Filtros")
    
    with st.container():
        col1, col2 = st.columns(2)
        
        with col1:
            volumen_min = st.number_input(
                "ğŸ“Š Volumen mÃ­nimo de opciones",
                min_value=0,
                value=5000,
                step=1000,
                help="Volumen mÃ­nimo de contratos de opciones (calls + puts)"
            )
        
        with col2:
            ratio_min = st.number_input(
                "ğŸ“ˆ Call/Put Ratio mÃ­nimo",
                min_value=0.0,
                value=0.5,
                step=0.1,
                format="%.2f",
                help="Ratio mÃ­nimo (>0.5 significa mÃ¡s calls que puts)"
            )
        
        st.markdown("---")
        
        # InformaciÃ³n adicional
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.info("**Volumen > 5000**: Alta liquidez en opciones")
        with col2:
            st.info("**Ratio > 0.5**: Sesgo alcista (mÃ¡s calls)")
        with col3:
            st.info("**Ratio > 1.0**: Fuerte sesgo alcista")
    
    return volumen_min, ratio_min

# =========================================================================
# 3. PROCESAMIENTO Y FILTRADO
# =========================================================================

def aplicar_filtros(df, volumen_min, ratio_min):
    """Aplica los filtros de volumen y call/put ratio"""
    if df is None:
        return None
    
    st.subheader("3. AplicaciÃ³n de Filtros")
    
    # Filtrar segÃºn criterios
    df_filtrado = df[
        (df['Options_Volume'] > volumen_min) & 
        (df['Call_Put_Ratio'] > ratio_min)
    ].copy()
    
    # Agregar columna de ranking por volumen
    df_filtrado = df_filtrado.sort_values('Options_Volume', ascending=False)
    df_filtrado.insert(0, 'Rank', range(1, len(df_filtrado) + 1))
    
    # Formatear columnas para display
    df_filtrado['Call_Put_Ratio'] = df_filtrado['Call_Put_Ratio'].apply(lambda x: f"{x:.2f}")
    df_filtrado['Price'] = df_filtrado['Price'].apply(lambda x: f"${x:.2f}")
    
    # MÃ©tricas de resumen
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        st.metric("ğŸ¯ Acciones Filtradas", len(df_filtrado))
    with col2:
        if len(df_filtrado) > 0:
            avg_ratio = df[df['Options_Volume'] > volumen_min]['Call_Put_Ratio'].mean()
            st.metric("ğŸ“Š Ratio Promedio", f"{avg_ratio:.2f}")
    with col3:
        ratio_gt_1 = len(df_filtrado[df_filtrado['Call_Put_Ratio'].astype(float) > 1.0])
        st.metric("ğŸš€ Ratio > 1.0", ratio_gt_1)
    with col4:
        if len(df_filtrado) > 0:
            total_vol = df_filtrado['Options_Volume'].sum()
            st.metric("ğŸ“ˆ Vol. Total", f"{total_vol:,.0f}")
    
    return df_filtrado

# =========================================================================
# 4. VISUALIZACIÃ“N DE RESULTADOS
# =========================================================================

def mostrar_resultados(df_resultados):
    """Muestra los resultados filtrados en tabla interactiva"""
    st.subheader("4. Resultados del Escaneo")
    
    if df_resultados is None or df_resultados.empty:
        st.warning("âš ï¸ No hay acciones que cumplan los criterios de filtrado")
        st.info("ğŸ’¡ Intenta reducir los valores mÃ­nimos de los filtros")
        return
    
    # Seleccionar columnas relevantes
    columnas_display = [
        'Rank', 'Ticker', 'Price', 'Volumen', 
        'Options_Volume', 'Call_Put_Ratio',
        'RSI', 'ROC18', 'Sharpe_ratio', 'Sector'
    ]
    
    df_display = df_resultados[columnas_display].copy()
    
    # Renombrar columnas para mejor presentaciÃ³n
    df_display.columns = [
        'ğŸ… Rank', 'ğŸ¯ Ticker', 'ğŸ’µ Precio', 'ğŸ“Š Vol. AcciÃ³n',
        'ğŸ“ˆ Vol. Opciones', 'ğŸ”¥ Call/Put Ratio',
        'ğŸ“Š RSI', 'ğŸ“ˆ ROC18', 'â­ Sharpe', 'ğŸ¢ Sector'
    ]
    
    # Tabla de resultados
    st.markdown("#### ğŸ† Acciones con Mayor Actividad en Opciones")
    st.dataframe(
        df_display,
        hide_index=True,
        use_container_width=True,
        column_config={
            "ğŸ… Rank": st.column_config.NumberColumn(width="small"),
            "ğŸ¯ Ticker": st.column_config.TextColumn(width="small"),
            "ğŸ’µ Precio": st.column_config.TextColumn(width="small"),
            "ğŸ“Š Vol. AcciÃ³n": st.column_config.NumberColumn(width="medium", format="%d"),
            "ğŸ“ˆ Vol. Opciones": st.column_config.NumberColumn(width="medium", format="%d"),
            "ğŸ”¥ Call/Put Ratio": st.column_config.TextColumn(width="small"),
            "ğŸ“Š RSI": st.column_config.NumberColumn(width="small", format="%.2f"),
            "ğŸ“ˆ ROC18": st.column_config.NumberColumn(width="small", format="%.2f"),
            "â­ Sharpe": st.column_config.NumberColumn(width="small", format="%.2f"),
            "ğŸ¢ Sector": st.column_config.TextColumn(width="medium")
        }
    )
    
    # GrÃ¡fico de distribuciÃ³n
    st.markdown("---")
    st.markdown("#### ğŸ“Š DistribuciÃ³n de Call/Put Ratio")
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Top 10 por ratio
        top_10_ratio = df_resultados.nlargest(10, 'Call_Put_Ratio')
        st.bar_chart(
            top_10_ratio.set_index('Ticker')['Call_Put_Ratio'].astype(float),
            use_container_width=True
        )
        st.caption("Top 10 acciones por Call/Put Ratio")
    
    with col2:
        # Top 10 por volumen
        top_10_vol = df_resultados.nlargest(10, 'Options_Volume')
        st.bar_chart(
            top_10_vol.set_index('Ticker')['Options_Volume'],
            use_container_width=True
        )
        st.caption("Top 10 acciones por Volumen de Opciones")
    
    # BotÃ³n de descarga
    st.markdown("---")
    csv = df_resultados.to_csv(index=False).encode('utf-8')
    st.download_button(
        label="ğŸ“¥ Descargar Resultados (CSV)",
        data=csv,
        file_name=f"options_scanner_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
        mime="text/csv",
        use_container_width=False
    )

# =========================================================================
# 5. FUNCIÃ“N PRINCIPAL
# =========================================================================

def options_scanner_page():
    st.title("ğŸ“Š Options Scanner - Call/Put Ratio Analyzer")
    st.markdown("---")
    st.info("ğŸ” Este escÃ¡ner identifica acciones con alta actividad en opciones y sesgo alcista")
    
    # Cargar datos
    st.divider()
    df_base = cargar_datos_csv()
    
    if df_base is not None:
        # Simular datos de opciones
        with st.spinner("Procesando datos de opciones..."):
            df_opciones = simular_datos_opciones(df_base)
        
        st.success(f"âœ… Datos procesados: {len(df_opciones)} acciones con informaciÃ³n de opciones")
        
        # Mostrar nota sobre datos simulados
        with st.expander("âš ï¸ Importante: Datos de Opciones Simulados"):
            st.warning("""
            **NOTA**: Los datos de Call/Put Ratio y Volumen de Opciones son simulados para demostraciÃ³n.
            
            Para usar datos reales, necesitas:
            1. Una API de datos de opciones (Schwab, Interactive Brokers, TDAmeritrade, etc.)
            2. Reemplazar la funciÃ³n `simular_datos_opciones()` con llamadas reales a la API
            3. La estructura del CSV debe incluir las columnas:
               - `Options_Volume`: Volumen total de opciones
               - `Call_Put_Ratio`: Ratio de calls vs puts
            """)
        
        # SecciÃ³n de filtros
        st.divider()
        volumen_min, ratio_min = seccion_filtros()
        
        # BotÃ³n de escaneo
        st.divider()
        col1, col2, col3 = st.columns([1, 2, 1])
        
        with col1:
            ejecutar_btn = st.button("ğŸš€ Aplicar Filtros", type="primary", use_container_width=True)
        
        with col2:
            if 'df_resultados' in st.session_state and st.session_state.df_resultados is not None:
                st.success(f"âœ… {len(st.session_state.df_resultados)} resultados actuales")
        
        with col3:
            if st.button("ğŸ—‘ï¸ Limpiar", use_container_width=True):
                if 'df_resultados' in st.session_state:
                    del st.session_state.df_resultados
                st.rerun()
        
        # Ejecutar filtrado
        if ejecutar_btn:
            with st.spinner("Aplicando filtros..."):
                df_resultados = aplicar_filtros(df_opciones, volumen_min, ratio_min)
                st.session_state.df_resultados = df_resultados
            
            if df_resultados is not None and not df_resultados.empty:
                st.success(f"âœ… Filtrado completado: {len(df_resultados)} acciones encontradas")
            else:
                st.warning("âš ï¸ No se encontraron acciones que cumplan los criterios")
        
        # Mostrar resultados
        st.divider()
        if 'df_resultados' in st.session_state:
            mostrar_resultados(st.session_state.df_resultados)
        else:
            st.info("ğŸ‘† Configura los filtros y presiona 'Aplicar Filtros' para ver los resultados")
    
    else:
        st.error("âŒ No se pudo cargar el archivo CSV. Verifica que existe en el directorio raÃ­z.")

# =========================================================================
# 6. PUNTO DE ENTRADA
# =========================================================================

if __name__ == "__main__":
    options_scanner_page()
